/*
 * AHX Synthesis Core - Implementation
 *
 * Authentic AHX synthesis algorithms extracted from ahx_player.c
 * Shared by both the module player and synth plugin
 */

#include "ahx_synth_core.h"
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifdef EMSCRIPTEN
#include <emscripten.h>
#endif

#define AMIGA_PAULA_PAL_CLK 3546895
#define AHX_FRAME_RATE 50
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define CLAMP(x, low, high) (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))

// AHX Period Table (from ahx_player.c:211) - converts note index to Amiga period
// Index 1 = lowest note (longest period), Index 60 = highest note (shortest period)
static const int AhxPeriodTable[61] = {
    0x0000, 0x0D60, 0x0CA0, 0x0BE8, 0x0B40, 0x0A98, 0x0A00, 0x0970,
    0x08E8, 0x0868, 0x07F0, 0x0780, 0x0714, 0x06B0, 0x0650, 0x05F4,
    0x05A0, 0x054C, 0x0500, 0x04B8, 0x0474, 0x0434, 0x03F8, 0x03C0,
    0x038A, 0x0358, 0x0328, 0x02FA, 0x02D0, 0x02A6, 0x0280, 0x025C,
    0x023A, 0x021A, 0x01FC, 0x01E0, 0x01C5, 0x01AC, 0x0194, 0x017D,
    0x0168, 0x0153, 0x0140, 0x012E, 0x011D, 0x010D, 0x00FE, 0x00F0,
    0x00E2, 0x00D6, 0x00CA, 0x00BE, 0x00B4, 0x00AA, 0x00A0, 0x0097,
    0x008F, 0x0087, 0x007F, 0x0078, 0x0071
};

// White noise table (from AHX player - 1920 bytes)
static const unsigned char WhiteNoiseBig[] = {
    0x7f,0x7f,0xa8,0xe2,0x78,0x3e,0x2c,0x92,0x52,0xd5,0x80,0x80,0xab,0x80,0x7f,0x37,
    0x7f,0x7f,0x15,0x3b,0xbc,0x66,0xf3,0x7f,0x80,0x80,0x80,0x80,0x42,0xe5,0xf8,0x80,
    0x7f,0x7f,0x26,0x7f,0x80,0x97,0x80,0x5f,0xa7,0x7f,0x80,0x80,0x80,0x7f,0x7f,0x7f,
    0xce,0x79,0x8c,0x80,0x4a,0x7f,0x80,0x16,0x7f,0x7f,0x80,0x80,0x09,0xf1,0x80,0x95,
    0x78,0x78,0x7f,0xb8,0xe2,0x52,0x7f,0x08,0x93,0x7f,0x7f,0x80,0xfb,0xa8,0x44,0xe5,
    0xca,0x09,0x7f,0x80,0x7f,0x80,0xcb,0x80,0x7f,0xf7,0x80,0x80,0xb7,0x7f,0x5b,0x80,
    0x3b,0x14,0xcf,0x80,0x7f,0x80,0x16,0x1f,0x67,0xa1,0x62,0x71,0x71,0xa7,0x7f,0x44,
    0x41,0x80,0x7f,0xcd,0x41,0x43,0x4b,0xf3,0x80,0xc7,0xdf,0xdf,0xd5,0x27,0x1f,0x1f,
    0x9f,0x36,0x24,0x73,0x71,0x7f,0x80,0x7f,0x79,0x42,0x7f,0x7f,0x80,0x80,0x80,0x2e,
    0x22,0x7f,0xf2,0x46,0x80,0x80,0xb4,0xd2,0x35,0x2e,0x80,0x8f,0xb5,0xbc,0x80,0x38,
    0xf2,0x7f,0x10,0x2d,0x7f,0x7f,0x26,0x91,0x7f,0xf0,0x7f,0xdf,0x2b,0x7f,0x80,0x3e,
    0x7f,0x7f,0x80,0x80,0xab,0xae,0x7f,0xca,0x80,0x80,0xf3,0xba,0x34,0x80,0x80,0x7f,
    0x7f,0x80,0x3e,0x66,0x80,0x17,0x80,0xab,0x80,0x09,0xf3,0x7f,0x29,0x80,0xc4,0x7f,
    0x80,0xd3,0x7f,0xba,0x80,0x7f,0x80,0x9d,0x7f,0x80,0x38,0x80,0x7f,0x7f,0x7f,0x69,
    0x7f,0x7f,0x15,0x4f,0x80,0x7c,0x8c,0x1b,0x7f,0x7f,0x80,0x80,0x70,0x2b,0x80,0x7f,
    0x5a,0xc1,0x7f,0x80,0x7f,0x45,0xbb,0x80,0x7f,0xf7,0xce,0x80,0x80,0x80,0xda,0x9d,
    0x7f,0x80,0x7f,0xba,0xe2,0x02,0x80,0x95,0xba,0x80,0xfa,0xfe,0x80,0xb4,0x80,0x80,
    0x88,0x7f,0x7f,0x12,0x80,0x80,0x0e,0x9b,0x80,0x80,0x4f,0xc9,0x2b,0x80,0x77,0xb5,
    0x7f,0x51,0x7f,0x7f,0x7f,0x7f,0x80,0x7f,0xf1,0x80,0x31,0xe6,0x80,0x7f,0x80,0xa5,
    0x80,0x7f,0xca,0x7f,0x25,0x80,0x92,0xb4,0x7f,0x80,0x97,0x7f,0x7f,0x94,0x20,0x1b,
    0x3b,0x7f,0xee,0xca,0x80,0x80,0x42,0x80,0x80,0xa3,0x80,0xc5,0xf1,0x80,0x7f,0x7f,
    0x7f,0x51,0xaf,0x7f,0x35,0x42,0x80,0x7f,0xf1,0x80,0xc5,0x7f,0x7f,0x7f,0x80,0x28,
    0x7f,0xb3,0x2c,0x2c,0xea,0x7f,0x7f,0x80,0x7f,0x21,0xa9,0x7f,0x34,0x7f,0xae,0x1e,
    0xc5,0xbf,0xae,0x7f,0x8b,0x37,0x7f,0x0d,0x80,0x73,0x23,0xbb,0x80,0x80,0xc6,0x80,
    0xb6,0x80,0x7f,0x80,0x80,0x7f,0x7f,0x80,0x21,0x7f,0x20,0x45,0xa7,0xca,0x7f,0x80,
    0x80,0x80,0x3d,0x7f,0x15,0x45,0xf3,0xd8,0x8b,0x9b,0xce,0x55,0x80,0x80,0x7f,0xbd,
    0xce,0x7f,0x36,0x80,0x7f,0xbf,0x62,0x23,0x07,0x25,0xf1,0xca,0x59,0x7f,0xaa,0x7f,
    0x7f,0x47,0x93,0x80,0x1b,0x21,0x80,0x9b,0xca,0x80,0x2d,0x80,0x98,0x7f,0x7f,0x7f,
    0xee,0x80,0x80,0x80,0x7f,0x20,0x3b,0x80,0x3c,0x22,0xcf,0x7f,0x80,0x80,0x59,0x9d,
    0x7f,0x2a,0x7f,0x80,0x7c,0x80,0xd3,0x21,0x80,0xa7,0x7f,0x7f,0x80,0x09,0x3d,0x7f,
    0x7f,0xae,0x80,0xa7,0x80,0x7f,0x73,0x05,0x3d,0x80,0x7f,0x7f,0x7f,0x26,0x3b,0x7f,
    0xf6,0x80,0x7f,0x5e,0x47,0xdf,0x80,0x7c,0x36,0x36,0x7f,0xff,0xbc,0xbc,0xbc,0x7f,
    0x7f,0x7f,0x80,0x80,0x4d,0x21,0x7f,0x7f,0x7f,0x41,0x4d,0x80,0x7f,0x7f,0x80,0xc0,
    0xaf,0x2c,0x7f,0x17,0x35,0x80,0x80,0x7f,0xf0,0x3c,0x12,0x87,0x7f,0x80,0x80,0x13,
    0x73,0x2d,0x3e,0x80,0x7f,0x80,0xa6,0xd8,0x19,0x80,0x7f,0x27,0x80,0x7f,0x80,0x7f,
    0x80,0x7f,0x23,0x80,0x4d,0x80,0x7f,0x7f,0x89,0x7f,0x80,0xb5,0x4a,0x17,0xaf,0x88,
    0x95,0x80,0x70,0x77,0x97,0x7f,0x80,0x80,0x22,0x9b,0x02,0x2f,0x80,0x80,0x98,0x7f,
    0x7f,0x12,0x2d,0x28,0xce,0xaf,0x90,0x58,0xe9,0x1a,0x71,0x2f,0x5c,0x7f,0x80,0x7f,
    0x7f,0x80,0x7f,0x47,0xcd,0xaf,0x2c,0x06,0x80,0x2f,0x80,0xe8,0x80,0x2e,0x58,0x11,
    0xd7,0xad,0x58,0x43,0x17,0x9f,0x70,0xc3,0x80,0x70,0x19,0xc3,0x37,0x2e,0x42,0x80,
    0x2c,0xbc,0x80,0x7f,0x7f,0x7f,0x10,0x45,0x2d,0x3e,0x3e,0x90,0x80,0xa6,0xd8,0x5b,
    0x80,0x7f,0x27,0x80,0x7f,0x80,0x33,0x80,0x75,0x80,0x7f,0x7f,0x94,0x80,0x21,0xf1,
    0x7f,0xee,0x7f,0xae,0xf6,0xae,0x80,0x41,0x80,0xa5,0x7f,0x40,0x7f,0x8a,0x3d,0x12,
    0xdd,0x7f,0x9e,0x7f,0x92,0x36,0x66,0x19,0x80,0x80,0xa7,0xa0,0x90,0x80,0x5f,0x23,
    0x57,0x80,0x31,0x80,0x2d,0x36,0xa0,0xd2,0x8f,0xd9,0x3f,0x80,0x3e,0x80,0x29,0xd8,
    0xad,0x7f,0x7f,0x51,0xbb,0x70,0xcb,0xb5,0xdc,0x3d,0xc2,0xb7,0x7f,0xba,0x80,0x3e,
    0x80,0x7f,0x3b,0x44,0x80,0xa6,0x7f,0x80,0x80,0x7c,0x80,0x61,0x7f,0xca,0x7f,0x7f,
    0x80,0xff,0x34,0x7f,0x46,0x05,0x7f,0x24,0x7f,0x7f,0x7f,0x7f,0xbc,0x7f,0x7f,0x7f,
    0x80,0x7f,0x15,0x7f,0xce,0xe5,0x7f,0x80,0x7f,0xbd,0x58,0x85,0x33,0x7f,0x7e,0x80,
    0x7f,0x20,0x58,0xdc,0x91,0x80,0xc4,0x79,0xdc,0xd1,0x80,0x80,0x27,0x7f,0x7f,0x7f,
    0x47,0x80,0x8d,0x80,0xcb,0xa6,0x98,0x12,0x9b,0x4b,0xc4,0x78,0x87,0x7f,0x2f,0x25,
    0xa1,0x7f,0xa9,0xc7,0xfe,0x7f,0x15,0x16,0xf6,0x80,0x37,0xde,0xe2,0x80,0x10,0x7f,
    0x62,0x7f,0x7f,0x7f,0x7f,0xe9,0x9e,0x7f,0x80,0x91,0x7f,0x37,0xd2,0xbd,0x7f,0x80,
    0x5e,0x7f,0x7f,0x38,0x7f,0x80,0x7f,0x80,0x93,0x51,0xca,0x3c,0x7f,0xb6,0x80,0x77,
    0x80,0xe6,0x13,0x2e,0x7f,0x09,0x80,0x80,0x7f,0x7f,0x89,0x80,0x59,0x95,0x08,0x19,
    0xd5,0x7f,0x46,0x7f,0xad,0x3f,0x7f,0x7f,0x80,0x7f,0x7f,0x80,0xba,0x80,0x80,0xe1,
    0x35,0x80,0x7f,0x11,0x59,0x80,0x80,0x80,0xc7,0xa6,0x9f,0x35,0x14,0x80,0x19,0x2e,
    0xdf,0x80,0x10,0xa6,0xee,0x8a,0x80,0x7f,0x80,0xbb,0x88,0x63,0x2e,0x7f,0x80,0x90,
    0x80,0x98,0x53,0xcb,0x80,0x95,0xd3,0x36,0x2e,0x87,0xc2,0x0a,0x7f,0x2c,0x58,0x7f,
    0x32,0x6d,0x19,0x44,0x21,0xda,0x6e,0x3e,0x7f,0x98,0xd9,0xeb,0xfe,0x05,0xae,0xbc,
    0x7f,0xed,0x11,0xcd,0x12,0xe1,0x70,0x14,0x1a,0x7f,0x4f,0x7f,0xb6,0x7f,0x31,0x80,
    0xab,0x85,0x24,0x39,0x19,0xca,0xc1,0x7f,0x65,0x06,0xee,0x75,0xae,0xb5,0x26,0x7f,
    0x80,0x2d,0x7f,0x51,0x80,0x80,0xfa,0x23,0x7f,0x1e,0x4f,0x2d,0x41,0xa9,0x2c,0x80,
    0xab,0x28,0x80,0x71,0x7f,0xd2,0xd2,0xd2,0xf1,0x0a,0x14,0xb6,0xb6,0xc6,0x1f,0x2d,
    0x1f,0xfa,0xb6,0x80,0xb3,0x90,0x8e,0xaa,0x19,0x7f,0x80,0xc3,0x37,0x7f,0x80,0xe6,
    0x80,0x7f,0x80,0x80,0x4e,0x33,0x7f,0xd1,0xd8,0xd8,0x0d,0x7f,0x88,0x2e,0x4a,0x80,
    0x02,0x85,0x92,0x7f,0xf7,0xa7,0xa7,0x19,0x80,0x30,0x2f,0x27,0xcb,0x80,0x7f,0x80,
    0xad,0x38,0x3b,0x71,0x1e,0x80,0x80,0x5c,0xe2,0x80,0xf1,0xd3,0x80,0x80,0x36,0x7f,
    0xeb,0x80,0x59,0x59,0x59,0x80,0x42,0x90,0x45,0x87,0xfa,0x99,0x4d,0x3f,0x7f,0x3c,
    0x14,0x2a,0x20,0xcf,0x80,0x5f,0x12,0xaa,0xce,0x8b,0xc1,0x80,0x7f,0xab,0xcb,0x4d,
    0x80,0x80,0x80,0x2b,0x37,0x0d,0x80,0x07,0x07,0x07,0x7f,0x7f,0x7f,0x17,0x33,0x80,
    0x80,0xfe,0xd7,0xa9,0x8c,0x36,0x2c,0x80,0xcb,0x95,0x77,0x11,0x36,0x22,0xed,0x0e,
    0x5b,0x2c,0x3d,0xc0,0x7f,0x80,0x34,0xb5,0x36,0x80,0x80,0x7f,0x80,0x38,0x80,0x80,
    0x89,0x25,0x80,0xa1,0x8c,0x0a,0x0a,0x47,0xbb,0x80,0xc0,0x2a,0x51,0x80,0xdc,0x8e,
    0x26,0xa6,0x7f,0xcb,0x8c,0x80,0xd5,0x80,0x98,0x2f,0xd9,0x5a,0x7f,0xcf,0x0e,0x7f,
    0x7f,0x4f,0x1e,0x8e,0x7f,0xb6,0x4a,0xe9,0x77,0x33,0x3f,0x3e,0x80,0x7f,0xbd,0x7f,
    0x19,0xd3,0x7f,0x7f,0x80,0x27,0x80,0x80,0xb7,0x53,0xa6,0x0a,0x4d,0xb6,0x2e,0x2e,
    0xc1,0x7f,0x46,0x7f,0x4a,0x5a,0x95,0xd1,0x12,0x80,0xd3,0x32,0x7f,0x80,0x1e,0x17,
    0x1e,0x14,0xb5,0x13,0x24,0x10,0x34,0x2a,0xa5,0x2f,0x80,0x7f,0x80,0x85,0x41,0x80,
    0x3b,0x2e,0xae,0x7f,0xce,0x80,0x80,0xb7,0xb5,0x8e,0x8d,0x2d,0xd5,0x33,0x33,0x99,
    0x77,0x7f,0x92,0x7f,0xbc,0x80,0x2e,0x12,0x44,0x77,0x7f,0x80,0x7f,0x7f,0x7f,0x77,
    0x80,0x24,0xde,0x0e,0x7f,0x80,0x7f,0x7f,0x80,0xc4,0x95,0x22,0x80,0x2d,0x4f,0x80,
    0xce,0x80,0x80,0xcb,0x31,0x26,0x80,0xaa,0xee,0xef,0xf1,0x7f,0x2c,0x80,0x89,0x30,
    0x29,0x13,0x7f,0x90,0xa6,0x80,0x80,0x9b,0x80,0x71,0xd9,0x2e,0x36,0x7f,0x80,0x2e,
    0x36,0xbb,0x16,0xad,0x87,0x2e,0x80,0x15,0xcb,0xcb,0x80,0x3b,0x7f,0x6d,0xcf,0x45,
    0xc7,0x2e,0x20,0x43,0x32,0xaa,0x80,0x97,0x10,0xd5,0x2f,0x44,0xaa,0x7f,0x80,0x21,
    0x80,0x3e,0x3c,0x7f,0x80,0x80,0x80,0x73,0x7f,0xc5,0x80,0x7f,0x46,0x37,0x33,0x7f,
    0x3d,0x7f,0xea,0x80,0x98,0x58,0x80,0xc6,0x11,0x31,0x80,0x21,0x53,0xa7,0x5c,0x80,
    0xd3,0x45,0x7f,0xaf,0xcf,0x4d,0xc6,0x80,0xb4,0xe1,0x80,0x7f,0x7f,0x7f,0x80,0x7f,
    0x7f,0x7f,0xbb,0xf1,0x1a,0x94,0x80,0x80,0x8d,0x8e,0xd3,0xba,0x09,0x7f,0x80,0x80,
    0xa1,0xa3,0x7f,0xd9,0x80,0x29,0x27,0x47,0x80,0xef,0x38,0x59,0x80,0x4d,0xb6,0x7f,
    0xbb,0x1a,0x15,0x80,0xe9,0x80,0xc6,0xa1,0x45,0x27,0x80,0x2f,0x95,0x7f,0x80,0x62,
    0x80,0x7f,0x80,0x23,0x80,0xc2,0xb7,0x77,0x89,0x51,0xc2,0x36,0x36,0x8f,0x13,0x43,
    0x36,0x3d,0x89,0x77,0x0a,0xb5,0xc0,0x38,0xfe,0xa9,0x80,0xb6,0x80,0x8c,0x8e,0xaa,
    0xae,0xb7,0x80,0x7f,0x7f,0x53,0x24,0x7f,0x80,0xc3,0x80,0xc1,0xee,0x58,0x7f,0x10,
    0x17,0xb6,0x7f,0x18,0x8a,0x24,0xb5,0xa1,0xae,0xc3,0x1f,0xb6,0x24,0xad,0x95,0x51,
    0xd3,0x7f,0x7f,0x37,0x30,0x73,0xc4,0x30,0x2e,0x1f,0x7f,0xa5,0xfe,0x80,0xd3,0xe2,
    0x80,0x31,0x91,0xc6,0x7f,0xbb,0xab,0x78,0xd1,0x10,0x47,0x80,0x80,0xe6,0xd9,0x8b,
    0x80,0x80,0x98,0xf1,0xa1,0xed,0x0e,0xba,0x80,0x98,0x7f,0xd8,0xaa,0x89,0xe9,0x9b,
    0x7f,0x80,0xc3,0x7f,0x4a,0x17,0x80,0xf1,0x7f,0x34,0x38,0x99,0x7f,0x80,0x80,0x5b,
    0x11,0x2a,0x3b,0x7f,0x3c,0x80,0x80,0x80,0x7f,0x24,0x80,0xea,0xc2,0x4a,0x95,0x7f,
    0xae,0x80,0xad,0x78,0x73,0x44,0x88,0xae,0xe5,0x89,0x80,0x94,0xa5,0xaf,0x1e,0x45,
    0xe9,0x7f,0x91,0x7f,0xaa,0x80,0x37,0x80,0x80,0xf0,0x97,0x05,0x1a,0x80,0x99,0xe2,
    0x7f,0xaf,0x33,0x80,0x7f,0xb3,0x80,0x27,0x66,0x8c,0x7f,0x8e,0x3e,0x3e,0x2d,0x7f,
    0xa1,0x80,0x99,0x7f,0xc4,0xe8,0x7f,0xf1,0x4a,0x17,0x92,0xd8,0x37,0x2f,0xc7,0x88,
    0x7f,0x47,0x7f,0x77,0x91,0xc0,0x31,0xfe,0x8e,0xe6,0x21,0x80,0x5e,0x20,0x66,0x2e,
    0x7f,0x15,0x80,0x09,0x47,0x66,0x80,0x80,0x6e,0x45,0x80,0x26,0x36,0x7f,0x80,0x4d,
    0x29,0x97,0x91,0x37,0x80,0x7f,0x34,0xc7,0x05,0xaa,0x2e,0xe8,0x98,0xe5,0x80,0xed,
    0x8c,0x31,0x34,0xd9,0x80,0x80,0xbc,0x2a,0x80,0xae,0x7f,0x9e,0x4f,0xa1,0x30,0x80,
    0x7f,0xc1,0xb6,0x7f,0x70,0x80,0x8a,0x2d,0x7f,0x80,0xa1,0x97,0x19,0x95,0x7f,0xab,
    0x9e,0x71,0x37,0x8e,0x80,0x80,0x92,0xd9,0x80,0x4b,0xad,0x2d,0x7f,0x80,0x99,0x37,
    0x90,0x91,0x1a,0x1e,0x45,0xd3,0x4a,0xca,0x97,0xb3,0xed,0x3f,0x9f,0x77,0xf0,0x36,
    0x46,0x80,0xf1,0xf7,0x7f,0x7f,0x0a,0x79,0x47,0x59,0x27,0x7f,0x20,0x97,0xb3,0x7f,
    0x16,0xf0,0xc4,0x34,0x98,0x23,0xf7,0xa7,0x1a,0x65,0x09,0x58,0x1f,0xaa,0x0e,0x7f,
    0x71,0x71,0x7f,0x34,0x7f,0x80,0xed,0x8e,0x9f,0x2c,0xce,0x9f,0x36,0x36,0x7f,0x41,
    0x71,0x71,0x71,0x38,0x5c,0x7f,0x0d,0x7f,0xaa,0x91,0x7f,0xab,0x2e,0xb7,0x42,0xaa,
    0x36,0x11,0x80,0x2c,0x95,0x80,0x24,0x97,0x0e,0x2a,0x80,0x15,0xf1,0x80,0x95,0x80,
    0x95,0x80,0x9f,0x4a,0x5c,0x85,0xa1,0x80,0xdf,0x43,0x2a,0xa9,0xa7,0xa7,0xaf,0xde,
    0x80,0x36,0xf0,0x59,0x15,0x80,0x7f,0xb6,0x85,0xbc,0x93,0xd2,0x99,0xf1,0x1f,0x3c,
    0x71,0x9b,0x8d,0x4b,0xcd,0x11,0x80,0x8c,0x31,0x80,0xa7,0x71,0x24,0x91,0x24,0x7f,
    0xeb,0x29,0x1f,0x80,0x4d,0x49,0x19,0x80,0x80,0x2f,0x9b,0x46,0x8f,0x71,0xd9,0x7f,
    0x19,0xef,0xc4,0xa0,0x27,0x06,0x80,0xe1,0x36,0x4f,0x80,0x97,0x9e,0x31,0x98,0x7f,
    0x71,0x99,0x80,0x0e,0xbc,0x91,0xf1,0xa1,0x91,0x31,0x80,0x1e,0x80,0xcb,0x7f,0x4d,
    0x9f,0x80,0xd3,0xf1,0x1a,0xf7,0x15,0xaa,0x85,0x15,0x4f,0xfa,0x13,0x5e,0x37,0x17,
    0x17,0x17,0xa5,0xa5,0x9e,0x98,0x4b,0x15,0x58,0x95,0x71,0x7f,0x89,0xa5,0xed,0x8d,
    0x32,0xf1,0x37,0x27,0x40,0x37,0x06,0xd8,0x80,0x1e,0x7f,0xcf,0x37,0xf6,0x3f,0x80,
    0x8e,0xc6,0x7f,0x5a,0x2e,0x17,0xd8,0x3c,0x92,0xc6,0x80,0x8e,0x94,0x80,0x91,0xed,
    0x80,0x4b,0x36,0x06,0xbb,0xf0,0x80,0xed,0x7f,0x2e,0x3c,0x90,0x3d,0x7f,0x89,0x31,
    0x80,0x05,0x77,0x5a,0xa1,0x98,0x1e,0x73,0xaa,0xe8,0xe8,0x1e,0xf1,0x36,0xb5,0x89,
    0x2f,0x1a,0xa7,0xaa,0x80,0x36,0xba,0x37,0xae,0xaa,0x66,0x80,0x18,0x47,0x34,0x23,
    0x23,0xf1,0x7f,0x2e,0x71,0x8d,0x7f,0xa7,0x7f,0x37,0x7f,0x95,0x11,0x80,0xa0,0x0e,
    0xe2,0x27,0x80,0xf7,0x18,0x8e,0xba,0x80,0x80,0x7f,0x80,0xae,0x24,0x3c,0x59,0xaf,
    0x47,0x98,0x7f,0x49,0x80,0x71,0x7f,0x80,0x18,0x80,0x37,0x80,0x2f,0xa1,0x51,0xa5,
    0x8d,0x80,0x7f,0x93,0x21,0x4b,0xb6,0x1a,0x18,0x23,0x1a,0x7f,0x3e,0xa6,0x71,0x99,
    0x80,0x59,0x7f,0xa9,0x53,0xb7,0x24,0x80,0x25,0x36,0xa7,0x7f,0x99,0xd9,0x15,0x19,
    0x91,0x80,0xf0,0x0e,0x93,0x43,0xd9,0x2f,0x7f,0x91,0x23,0x25,0x7f,0x2e,0x77,0xb3,
    0x88,0x3e,0x95,0xef,0x19,0x7f,0x3e,0x9b,0xa5,0x37,0x7f,0x9b,0x37,0x8b,0x2c,0x80
};

// MIDI note to Amiga period conversion table (based on C-2 = period 428)
static const int note_to_period_table[128] = {
    // Extended for full MIDI range
    6848, 6464, 6096, 5760, 5424, 5120, 4832, 4560, 4304, 4064, 3840, 3616,  // Octave 0
    3424, 3232, 3048, 2880, 2712, 2560, 2416, 2280, 2152, 2032, 1920, 1808,  // Octave 1
    1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016,  960,  904,  // Octave 2
     856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480,  452,  // Octave 3
     428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240,  226,  // Octave 4 (C-2 = 428)
     214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120,  113,  // Octave 5
     107,  101,   95,   90,   85,   80,   75,   71,   67,   63,   60,   56,  // Octave 6
      53,   50,   47,   45,   42,   40,   37,   35,   33,   31,   30,   28,  // Octave 7
      26,   25,   23,   22,   21,   20,   18,   17,   16,   15,   15,   14,  // Octave 8
      13,   12,   11,   11,   10,   10,    9,    8,    8,    7,    7,    7,  // Octave 9
       6,    6,    5,    5,    5,    5,    4,    4  // Octave 10 (partial, MIDI ends at 127)
};

// ============================================================================
// Waveform Generation (AUTHENTIC AHX ALGORITHMS from ahx_player.c:475-527)
// ============================================================================

// Generate triangle wave (authentic AHX algorithm)
static void waves_generate_triangle(int16_t* buffer, int len) {
    int d2 = len;
    int d5 = d2 >> 2;
    int d1 = 32768 / d5;  // 16-bit range: 256x larger than 8-bit
    int d4 = -(d2 >> 1);
    int16_t* edi = buffer;
    int eax = 0;

    for (int ecx = 0; ecx < d5; ecx++) {
        *edi++ = eax;
        eax += d1;
    }
    *edi++ = 0x7fff;  // Max positive 16-bit
    if (d5 != 1) {
        eax = 32768;
        for (int ecx = 0; ecx < d5-1; ecx++) {
            eax -= d1;
            *edi++ = eax;
        }
    }
    int16_t* esi = edi + d4;
    for (int ecx = 0; ecx < d5*2; ecx++) {
        *edi++ = *esi++;
        if (edi[-1] == 0x7fff) edi[-1] = -32768;  // Flip peak to negative
        else edi[-1] = -edi[-1];
    }
}

// Generate square wave with 32 different pulse widths (authentic AHX)
static void waves_generate_square(int16_t* buffer) {
    int16_t* edi = buffer;
    for (int ebx = 1; ebx <= 0x20; ebx++) {
        for (int ecx = 0; ecx < (0x40-ebx)*2; ecx++) *edi++ = -32768;  // Min 16-bit
        for (int ecx = 0; ecx < ebx*2; ecx++) *edi++ = 0x7fff;  // Max 16-bit
    }
}

// Generate sawtooth wave (authentic AHX)
static void waves_generate_sawtooth(int16_t* buffer, int len) {
    int16_t* edi = buffer;
    int ebx = 65536 / (len-1);  // 16-bit range: 65536 total values
    int eax = -32768;
    for (int ecx = 0; ecx < len; ecx++) {
        *edi++ = eax;
        eax += ebx;
    }
}

// Generate white noise (authentic AHX)
static void waves_generate_white_noise(int16_t* buffer, int len) {
    // Scale 8-bit noise table to 16-bit (multiply by 256)
    for (int i = 0; i < len; i++) {
        int8_t sample8 = (int8_t)WhiteNoiseBig[i];  // Convert to signed
        buffer[i] = sample8 * 256;  // Scale to 16-bit range
    }
}

// Generate waveform and populate VoiceBuffer based on waveform type and wave_length
void ahx_synth_generate_waveform(AhxSynthVoice* voice, uint8_t waveform, uint8_t wave_length) {
    int16_t temp_buffer[0x281];

    // Generate base waveform at different lengths (matching AHX waves structure)
    switch (waveform) {
        case 0:  // Triangle
            switch (wave_length) {
                case 0: waves_generate_triangle(temp_buffer, 0x04); break;
                case 1: waves_generate_triangle(temp_buffer, 0x08); break;
                case 2: waves_generate_triangle(temp_buffer, 0x10); break;
                case 3: waves_generate_triangle(temp_buffer, 0x20); break;
                case 4: waves_generate_triangle(temp_buffer, 0x40); break;
                case 5: waves_generate_triangle(temp_buffer, 0x80); break;
                default: waves_generate_triangle(temp_buffer, 0x04); break;
            }
            break;

        case 1:  // Sawtooth
            switch (wave_length) {
                case 0: waves_generate_sawtooth(temp_buffer, 0x04); break;
                case 1: waves_generate_sawtooth(temp_buffer, 0x08); break;
                case 2: waves_generate_sawtooth(temp_buffer, 0x10); break;
                case 3: waves_generate_sawtooth(temp_buffer, 0x20); break;
                case 4: waves_generate_sawtooth(temp_buffer, 0x40); break;
                case 5: waves_generate_sawtooth(temp_buffer, 0x80); break;
                default: waves_generate_sawtooth(temp_buffer, 0x04); break;
            }
            break;

        case 2:  // Square - generate simple 50% square at appropriate wave_length
            {
                // Generate based on wave_length like other waveforms
                int wave_samples = 4 * (1 << wave_length);  // 4, 8, 16, 32, 64, 128
                int half = wave_samples / 2;

                // Simple 50% duty cycle
                for (int i = 0; i < half; i++) {
                    temp_buffer[i] = -32768;  // Low
                }
                for (int i = half; i < wave_samples; i++) {
                    temp_buffer[i] = 32767;  // High
                }
            }
            break;

        case 3:  // White noise
            waves_generate_white_noise(temp_buffer, 0x280);
            break;

        default:
            memset(temp_buffer, 0, 0x281 * sizeof(int16_t));
            break;
    }

    // Populate VoiceBuffer by repeating the waveform (matching player_set_audio logic)
    if (waveform == 3) {
        // Noise: copy directly
        memcpy(voice->VoiceBuffer, temp_buffer, 0x280 * sizeof(int16_t));
    } else {
        // Other waveforms: repeat to fill buffer
        int wave_loops = (1 << (5 - wave_length)) * 5;
        int wave_size = 4 * (1 << wave_length);
        for (int i = 0; i < wave_loops; i++) {
            memcpy(&voice->VoiceBuffer[i * wave_size], temp_buffer, wave_size * sizeof(int16_t));
        }
    }

    // Wrap-around sample for interpolation
    voice->VoiceBuffer[0x280] = voice->VoiceBuffer[0];
}

// Initialize voice
void ahx_synth_voice_init(AhxSynthVoice* voice) {
    memset(voice, 0, sizeof(AhxSynthVoice));
    memset(voice->VoiceBuffer, 0, 0x281 * sizeof(int16_t));

    // Initialize tracker components
    tracker_modulator_init(&voice->filter_mod);
    tracker_modulator_init(&voice->square_mod);
    tracker_voice_init(&voice->voice_playback);

    // Set tracker voice volume to 1 (we apply volume separately via VoiceVolume)
    tracker_voice_set_volume(&voice->voice_playback, 1);

    voice->TrackOn = true;
    voice->NoteMaxVolume = 0x40;  // Default max volume
    voice->WNRandom = 0x280;      // White noise seed
}

// Calculate ADSR deltas (AUTHENTIC AHX ALGORITHM from ahx_player.c:389)
void ahx_synth_voice_calc_adsr(AhxSynthVoice* voice, const AhxCoreInstrument* instrument) {
    voice->Instrument = instrument;

    // Calculate deltas per frame (exactly as AHX does it)
    if (instrument->Envelope.aFrames > 0) {
        voice->ADSR.aFrames = instrument->Envelope.aFrames;
        voice->ADSR.aVolume = instrument->Envelope.aVolume * 256 / voice->ADSR.aFrames;
    } else {
        voice->ADSR.aFrames = 1;
        voice->ADSR.aVolume = instrument->Envelope.aVolume * 256;
    }

    if (instrument->Envelope.dFrames > 0) {
        voice->ADSR.dFrames = instrument->Envelope.dFrames;
        voice->ADSR.dVolume = (instrument->Envelope.dVolume - instrument->Envelope.aVolume) * 256 / voice->ADSR.dFrames;
    } else {
        voice->ADSR.dFrames = 1;
        voice->ADSR.dVolume = (instrument->Envelope.dVolume - instrument->Envelope.aVolume) * 256;
    }

    voice->ADSR.sFrames = instrument->Envelope.sFrames;

    if (instrument->Envelope.rFrames > 0) {
        voice->ADSR.rFrames = instrument->Envelope.rFrames;
        voice->ADSR.rVolume = (instrument->Envelope.rVolume - instrument->Envelope.dVolume) * 256 / voice->ADSR.rFrames;
    } else {
        voice->ADSR.rFrames = 1;
        voice->ADSR.rVolume = (instrument->Envelope.rVolume - instrument->Envelope.dVolume) * 256;
    }
}

// Convert MIDI note to AHX note index (1-60 range for PeriodTable)
int ahx_synth_note_to_period(uint8_t note) {
    // Map MIDI notes to AHX note range (1-60)
    // MIDI 24 (C1) -> AHX 1 (lowest)
    // MIDI 83 (B5) -> AHX 60 (highest)
    int ahx_note = (int)note - 23;  // Offset to align with AHX range

    // Clamp to valid AHX note range
    if (ahx_note < 1) ahx_note = 1;
    if (ahx_note > 60) ahx_note = 60;

    return ahx_note;  // Return AHX note INDEX (not period!)
}

// Get Amiga period for AHX note index
int ahx_synth_get_period_for_note(int ahx_note) {
    // Clamp to valid range
    if (ahx_note < 1) ahx_note = 1;
    if (ahx_note > 60) ahx_note = 60;

    return AhxPeriodTable[ahx_note];
}

// Trigger note on
void ahx_synth_voice_note_on(AhxSynthVoice* voice, uint8_t note, uint8_t velocity, uint32_t sample_rate) {
    if (!voice || !voice->Instrument) return;

    voice->Released = false;
    voice->TrackOn = true;
    voice->samples_per_frame = sample_rate / AHX_FRAME_RATE;
    voice->samples_in_frame = 0;

#ifdef EMSCRIPTEN
    emscripten_log(EM_LOG_CONSOLE, "[AHX] Note on: sample_rate=%d, samples_per_frame=%d",
        sample_rate, voice->samples_per_frame);
#endif

    // Reset frame counter for debugging
    voice->debug_frame_count = 0;

    // Convert MIDI note to AHX note index (1-60) - NOT period!
    voice->InstrPeriod = ahx_synth_note_to_period(note);  // Stores AHX note INDEX
    voice->PlantPeriod = 1;  // Signal that period needs calculation

    // VoicePeriod will be calculated in first process_frame() from PeriodTable lookup
    voice->VoicePeriod = AhxPeriodTable[voice->InstrPeriod];

    // Set velocity as volume
    voice->NoteMaxVolume = (velocity * 64) / 127;
    if (voice->NoteMaxVolume > 64) voice->NoteMaxVolume = 64;

    // Reset ADSR to attack phase
    voice->ADSRVolume = 0;

    // CRITICAL: Recalculate ADSR deltas to reset frame counters
#ifdef EMSCRIPTEN
    if (!voice->Instrument) {
        emscripten_log(EM_LOG_ERROR, "[AHX] ERROR: Instrument pointer is NULL!");
    } else {
        emscripten_log(EM_LOG_CONSOLE, "[AHX] Instrument envelope BEFORE calc: a=%d(%d) d=%d(%d) s=%d r=%d(%d)",
            voice->Instrument->Envelope.aFrames, voice->Instrument->Envelope.aVolume,
            voice->Instrument->Envelope.dFrames, voice->Instrument->Envelope.dVolume,
            voice->Instrument->Envelope.sFrames,
            voice->Instrument->Envelope.rFrames, voice->Instrument->Envelope.rVolume);
    }
#endif

    ahx_synth_voice_calc_adsr(voice, voice->Instrument);

#ifdef EMSCRIPTEN
    emscripten_log(EM_LOG_CONSOLE, "[AHX] Calculated ADSR runtime AFTER calc: a=%d d=%d s=%d r=%d",
        voice->ADSR.aFrames, voice->ADSR.dFrames, voice->ADSR.sFrames, voice->ADSR.rFrames);
#endif

    // Reset vibrato
    voice->VibratoDelay = voice->Instrument->VibratoDelay;
    voice->VibratoCurrent = 0;
    voice->VibratoPeriod = 0;
    voice->VibratoDepth = voice->Instrument->VibratoDepth;
    voice->VibratoSpeed = voice->Instrument->VibratoSpeed;

    // Setup filter modulation
    if (voice->Instrument->FilterLowerLimit != voice->Instrument->FilterUpperLimit) {
        tracker_modulator_set_active(&voice->filter_mod, true);
        tracker_modulator_set_limits(&voice->filter_mod,
            voice->Instrument->FilterLowerLimit,
            voice->Instrument->FilterUpperLimit);
        tracker_modulator_set_speed(&voice->filter_mod, voice->Instrument->FilterSpeed);
        tracker_modulator_init(&voice->filter_mod);  // Reset to start
    } else {
        tracker_modulator_set_active(&voice->filter_mod, false);
    }

    // Setup PWM modulation
    if (voice->Instrument->SquareLowerLimit != voice->Instrument->SquareUpperLimit) {
        tracker_modulator_set_active(&voice->square_mod, true);
        tracker_modulator_set_limits(&voice->square_mod,
            voice->Instrument->SquareLowerLimit,
            voice->Instrument->SquareUpperLimit);
        tracker_modulator_set_speed(&voice->square_mod, voice->Instrument->SquareSpeed);
        tracker_modulator_init(&voice->square_mod);  // Reset to start
    } else {
        tracker_modulator_set_active(&voice->square_mod, false);
    }

    // Setup hard cut release
    voice->HardCutRelease = voice->Instrument->HardCutRelease;
    voice->HardCutReleaseF = voice->Instrument->HardCutReleaseFrames;
    voice->NoteCutOn = 0;
    voice->NoteCutWait = 0;

    // Set waveform and wave length from instrument
    voice->Waveform = voice->Instrument->Waveform;
    voice->WaveLength = voice->Instrument->WaveLength;

#ifdef EMSCRIPTEN
    emscripten_log(EM_LOG_CONSOLE, "[AHX] Generating waveform: type=%d, length=%d", voice->Waveform, voice->WaveLength);
    emscripten_log(EM_LOG_CONSOLE, "[AHX] MIDI note=%d, AHX note=%d, Period=%d", note, voice->InstrPeriod, voice->VoicePeriod);
#endif

    // Generate waveform and populate VoiceBuffer
    ahx_synth_generate_waveform(voice, voice->Waveform, voice->WaveLength);

    // Setup voice playback with period and waveform buffer
    tracker_voice_set_period(&voice->voice_playback, voice->VoicePeriod, AMIGA_PAULA_PAL_CLK, sample_rate);
    tracker_voice_set_waveform_16bit(&voice->voice_playback, voice->VoiceBuffer, 0x280);

    // Set tracker voice volume to 1 (we apply volume separately via VoiceVolume)
    tracker_voice_set_volume(&voice->voice_playback, 1);

    // CRITICAL: Reset playback position to start of waveform
    tracker_voice_reset_position(&voice->voice_playback);
}

// Trigger note off
void ahx_synth_voice_note_off(AhxSynthVoice* voice) {
    if (!voice) return;

    voice->Released = true;

    if (voice->Instrument && voice->Instrument->HardCutRelease) {
        // Hard cut release: immediate cut with short fade
        voice->NoteCutOn = 1;
        voice->NoteCutWait = 0;
    }
    // Normal release happens in process_frame via ADSR
}

// Process one frame (AUTHENTIC AHX ALGORITHM from ahx_player.c:901)
void ahx_synth_voice_process_frame(AhxSynthVoice* voice) {
    if (!voice || !voice->TrackOn || !voice->Instrument) return;

    static int frame_count = 0;
    if (frame_count < 50) {  // Log first 50 frames
#ifdef EMSCRIPTEN
        emscripten_log(EM_LOG_CONSOLE, "[Frame %d] ADSR: a=%d d=%d s=%d r=%d, vol=%d, TrackOn=%d",
            frame_count++, voice->ADSR.aFrames, voice->ADSR.dFrames, voice->ADSR.sFrames, voice->ADSR.rFrames,
            voice->ADSRVolume >> 8, voice->TrackOn);
#endif
    }

    // Hard cut release processing
    if (voice->HardCutRelease && voice->NoteCutOn) {
        if (voice->NoteCutWait <= 0) {
            voice->NoteCutOn = 0;
            // Recalculate release for hard cut
            int target_vol = voice->Instrument->Envelope.rVolume;
            int frames = voice->HardCutReleaseF ? voice->HardCutReleaseF : 1;

            // Force immediate transition to release phase
            voice->ADSR.aFrames = 0;
            voice->ADSR.dFrames = 0;
            voice->ADSR.sFrames = 0;
            voice->ADSR.rFrames = frames;
            voice->ADSR.rVolume = -(voice->ADSRVolume - (target_vol << 8)) / frames;
        } else {
            voice->NoteCutWait--;
        }
    }

    // ADSR envelope (EXACT ALGORITHM from ahx_player.c:948-962)
    if (voice->ADSR.aFrames) {
        voice->ADSRVolume += voice->ADSR.aVolume;
        if (--voice->ADSR.aFrames <= 0)
            voice->ADSRVolume = voice->Instrument->Envelope.aVolume << 8;
    } else if (voice->ADSR.dFrames) {
        voice->ADSRVolume += voice->ADSR.dVolume;
        if (--voice->ADSR.dFrames <= 0) {
            voice->ADSRVolume = voice->Instrument->Envelope.dVolume << 8;
            // If sustain_frames=0, skip to release immediately (for percussion)
            if (voice->Instrument->Envelope.sFrames == 0) {
                // Recalculate release from decay volume to release volume
                if (voice->Instrument->Envelope.rFrames > 0) {
                    voice->ADSR.rFrames = voice->Instrument->Envelope.rFrames;
                    voice->ADSR.rVolume = (voice->Instrument->Envelope.rVolume - voice->Instrument->Envelope.dVolume) * 256 / voice->ADSR.rFrames;
                } else {
                    voice->ADSR.rFrames = 1;
                    voice->ADSR.rVolume = (voice->Instrument->Envelope.rVolume - voice->Instrument->Envelope.dVolume) * 256;
                }
            }
        }
    } else if (voice->ADSR.sFrames) {
        // Sustain phase - count down frames
        if (--voice->ADSR.sFrames <= 0) {
            // Sustain finished - reset release phase from instrument
            voice->ADSR.sFrames = 0;

            // Recalculate release from current decay volume to release volume
            if (voice->Instrument->Envelope.rFrames > 0) {
                voice->ADSR.rFrames = voice->Instrument->Envelope.rFrames;
                voice->ADSR.rVolume = (voice->Instrument->Envelope.rVolume - voice->Instrument->Envelope.dVolume) * 256 / voice->ADSR.rFrames;
            } else {
                voice->ADSR.rFrames = 1;
                voice->ADSR.rVolume = (voice->Instrument->Envelope.rVolume - voice->Instrument->Envelope.dVolume) * 256;
            }
        }
    } else if (voice->ADSR.rFrames) {
        voice->ADSRVolume += voice->ADSR.rVolume;
        if (--voice->ADSR.rFrames <= 0) {
            voice->ADSRVolume = voice->Instrument->Envelope.rVolume << 8;
            // Release finished - ALWAYS stop voice
            // Even if release volume > 0, we've completed the envelope
            voice->TrackOn = false;
        }
    } else {
        // All ADSR stages complete - voice should be off
        // This shouldn't be reached, but safety stop
        voice->TrackOn = false;
    }

    // Vibrato
    if (voice->VibratoDelay > 0) {
        voice->VibratoDelay--;
    } else {
        voice->VibratoCurrent = (voice->VibratoCurrent + voice->VibratoSpeed) & 0xFF;
        // Sine-based vibrato (simplified)
        int vib_table_value = (int)(sinf(voice->VibratoCurrent * 3.14159f / 128.0f) * voice->VibratoDepth * 8);
        voice->VibratoPeriod = vib_table_value;
    }

    // Update filter modulation
    if (tracker_modulator_is_active(&voice->filter_mod)) {
        tracker_modulator_update(&voice->filter_mod);
    }

    // Update PWM modulation
    if (tracker_modulator_is_active(&voice->square_mod)) {
        tracker_modulator_update(&voice->square_mod);
    }

    // Process waveform changes (AUTHENTIC AHX ALGORITHM from ahx_player.c:1204)
    if (voice->NewWaveform) {
        ahx_synth_generate_waveform(voice, voice->Waveform, voice->WaveLength);

        // Update voice playback with new waveform buffer (16-bit)
        tracker_voice_set_waveform_16bit(&voice->voice_playback, voice->VoiceBuffer, 0x280);

        voice->NewWaveform = 0;
    }

    // Calculate final voice volume
    int adsr_vol = voice->ADSRVolume >> 8;  // Convert from fixed point (8-bit)
    voice->VoiceVolume = (voice->NoteMaxVolume * adsr_vol * voice->Instrument->Volume) >> 12;
    if (voice->VoiceVolume > 64) voice->VoiceVolume = 64;
    if (voice->VoiceVolume < 0) voice->VoiceVolume = 0;

    // Calculate final period with vibrato (AUTHENTIC AHX from ahx_player.c:1228-1261)
    if (voice->PlantPeriod) {
        voice->PlantPeriod = 0;

        // Calculate audio period from instrument note index (ahx_player.c:1228-1233)
        int audio_period = voice->InstrPeriod;

        // Note: In full AHX player, this would add Transpose + TrackPeriod
        // For synth mode we skip transpose since we're using MIDI directly

        // Clamp to valid note range
        if (audio_period > 60) audio_period = 60;
        if (audio_period < 0) audio_period = 0;

        // Look up actual Amiga period from table
        audio_period = AhxPeriodTable[audio_period];

        // Add portamento and vibrato
        voice->VoicePeriod = audio_period + voice->VibratoPeriod;

        // Clamp to valid period range
        if (voice->VoicePeriod < 113) voice->VoicePeriod = 113;
        if (voice->VoicePeriod > 6848) voice->VoicePeriod = 6848;
    }
}

// Process audio samples
uint32_t ahx_synth_voice_process(AhxSynthVoice* voice, float* output, uint32_t num_samples, uint32_t sample_rate) {
    if (!voice || !output || !voice->TrackOn) {
        if (output) {
            memset(output, 0, num_samples * sizeof(float));
        }
        return 0;
    }

    for (uint32_t i = 0; i < num_samples; i++) {
        // Process frame timing (50Hz)
        if (voice->samples_in_frame >= voice->samples_per_frame) {
            ahx_synth_voice_process_frame(voice);
            voice->samples_in_frame = 0;

            // Update voice period if changed
            tracker_voice_set_period(&voice->voice_playback, voice->VoicePeriod, AMIGA_PAULA_PAL_CLK, sample_rate);
        }
        voice->samples_in_frame++;

        // Get raw sample from voice playback (without volume/panning applied)
        int32_t sample = tracker_voice_get_sample(&voice->voice_playback);

        // Apply volume and convert to float
        // Reduce output to 50% to prevent clipping when mixing 4 voices
        float sample_f = sample / 32768.0f;
        float vol = (voice->VoiceVolume / 64.0f) * 0.5f;
        output[i] = sample_f * vol;

        if (!voice->TrackOn) {
            // Voice stopped - clear remaining buffer
            memset(&output[i + 1], 0, (num_samples - i - 1) * sizeof(float));
            return i + 1;
        }
    }

    return num_samples;
}

// Check if voice is active
bool ahx_synth_voice_is_active(const AhxSynthVoice* voice) {
    return voice && voice->TrackOn;
}

// Reset voice
void ahx_synth_voice_reset(AhxSynthVoice* voice) {
    if (!voice) return;

    const AhxCoreInstrument* inst = voice->Instrument;
    ahx_synth_voice_init(voice);
    voice->Instrument = inst;
}
