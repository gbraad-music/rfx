#!/usr/bin/env python3
"""
Auto-generate WASM function name mappings from Emscripten output.
This script parses regroove-effects.js and updates audio-worklet-processor.js
with the correct minified function name mappings.
"""

import re
import json

# Read the generated Emscripten JS file
with open('regroove-effects.js', 'r') as f:
    js_content = f.read()

# Extract mappings from assignWasmExports function
# Format: _fx_name=Module["_fx_name"]=wasmExports["minified"];
export_pattern = r'(_fx_[a-z_0-9]+)=Module\["\1"\]=wasmExports\["([a-zA-Z$_][a-zA-Z0-9$_]*)"\]'

matches = re.findall(export_pattern, js_content)

# Build reverse mapping: full_name -> minified_name
name_map = {}
for full_name, minified in matches:
    name_map[full_name] = minified

# Also get malloc and free
malloc_match = re.search(r'_malloc=Module\["_malloc"\]=wasmExports\["([a-zA-Z]+)"\]', js_content)
free_match = re.search(r'_free=Module\["_free"\]=wasmExports\["([a-zA-Z]+)"\]', js_content)

print(f"Found {len(name_map)} function mappings")

# Define effect structure
effects = {
    'model1_trim': 'fx_model1_trim',
    'model1_hpf': 'fx_model1_hpf',
    'model1_lpf': 'fx_model1_lpf',
    'model1_sculpt': 'fx_model1_sculpt',
    'distortion': 'fx_distortion',
    'filter': 'fx_filter',
    'eq': 'fx_eq',
    'compressor': 'fx_compressor',
    'delay': 'fx_delay',
    'reverb': 'fx_reverb',
    'phaser': 'fx_phaser',
    'stereo_widen': 'fx_stereo_widen'
}

# Build mapping structure
mappings = {
    'create': {},
    'set_enabled': {},
    'reset': {},
    'process': {},
    'params': {}
}

param_lists = {
    'model1_trim': ['drive'],
    'model1_hpf': ['cutoff'],
    'model1_lpf': ['cutoff'],
    'model1_sculpt': ['frequency', 'gain'],
    'distortion': ['drive', 'mix'],
    'filter': ['cutoff', 'resonance'],
    'eq': ['low', 'mid', 'high'],
    'compressor': ['threshold', 'ratio', 'attack', 'release', 'makeup'],
    'delay': ['time', 'feedback', 'mix'],
    'reverb': ['size', 'damping', 'mix'],
    'phaser': ['rate', 'depth', 'feedback'],
    'stereo_widen': ['width', 'mix']
}

# Populate mappings
for effect_name, prefix in effects.items():
    # Core functions
    create_key = f'_{prefix}_create'
    if create_key in name_map:
        mappings['create'][effect_name] = name_map[create_key]

    set_enabled_key = f'_{prefix}_set_enabled'
    if set_enabled_key in name_map:
        mappings['set_enabled'][effect_name] = name_map[set_enabled_key]

    reset_key = f'_{prefix}_reset'
    if reset_key in name_map:
        mappings['reset'][effect_name] = name_map[reset_key]

    # Process function
    if effect_name.startswith('model1_'):
        process_key = f'_{prefix}_process_interleaved'
    else:
        process_key = f'_{prefix}_process_f32'
    if process_key in name_map:
        mappings['process'][effect_name] = name_map[process_key]

    # Parameters
    if effect_name in param_lists:
        mappings['params'][effect_name] = {}
        for param in param_lists[effect_name]:
            param_key = f'_{prefix}_set_{param}'
            if param_key in name_map:
                mappings['params'][effect_name][param] = name_map[param_key]

# Special case: model1_trim peak level getter
peak_level_key = '_fx_model1_trim_get_peak_level'
peak_level_minified = name_map.get(peak_level_key, '$a')

# Generate JavaScript object literal
def format_obj(obj, indent=12):
    """Format a Python dict as a JavaScript object literal"""
    if not obj:
        return '{}'

    lines = []
    items = list(obj.items())
    for i, (key, value) in enumerate(items):
        if isinstance(value, dict):
            formatted_value = format_obj(value, indent + 4)
            lines.append(f"{' ' * indent}{key}: {formatted_value}")
        else:
            lines.append(f"{' ' * indent}{key}: '{value}'")
        if i < len(items) - 1:
            lines[-1] += ','

    return '{\n' + '\n'.join(lines) + '\n' + ' ' * (indent - 4) + '}'

# Read current audio-worklet-processor.js
with open('audio-worklet-processor.js', 'r') as f:
    worklet_content = f.read()

# Generate new WASM_FUNCS object
new_funcs = f"""        // WASM function name mappings (auto-generated by update-wasm-mappings.py)
        this.WASM_FUNCS = {{
            create: {format_obj(mappings['create'])},
            set_enabled: {format_obj(mappings['set_enabled'])},
            reset: {format_obj(mappings['reset'])},
            process: {format_obj(mappings['process'])},
            params: {format_obj(mappings['params'])}
        }};"""

# Replace the WASM_FUNCS definition
pattern = r'        // WASM function name mappings.*?\n        this\.WASM_FUNCS = \{[^}]+\}[^}]+\}[^}]+\}[^}]+\}[^}]+\}[^}]+\};'
worklet_content = re.sub(pattern, new_funcs, worklet_content, flags=re.DOTALL)

# Also update the hardcoded peak level function reference
worklet_content = re.sub(
    r"const getPeakLevelFn = this\.wasmModule\['[^']+'\]; // fx_model1_trim_get_peak_level",
    f"const getPeakLevelFn = this.wasmModule['{peak_level_minified}']; // fx_model1_trim_get_peak_level",
    worklet_content
)

# Write updated file
with open('audio-worklet-processor.js', 'w') as f:
    f.write(worklet_content)

# ALSO write mappings as JSON for easy drop-in
mappings_json = {
    'create': mappings['create'],
    'set_enabled': mappings['set_enabled'],
    'reset': mappings['reset'],
    'process': mappings['process'],
    'params': mappings['params'],
    'special': {
        'model1_trim_get_peak_level': peak_level_minified
    }
}

with open('wasm-mappings.json', 'w') as f:
    json.dump(mappings_json, f, indent=2)

print("âœ… Updated audio-worklet-processor.js with new mappings")
print("âœ… Generated wasm-mappings.json")
print(f"   Peak level getter: '{peak_level_minified}'")
print("\nðŸ“¦ Drop-in files for other projects:")
print("   - regroove-effects.wasm")
print("   - regroove-effects.js")
print("   - wasm-mappings.json")
print("\nSample mappings:")
for category in ['create', 'set_enabled', 'params']:
    print(f"\n  {category}:")
    items = list(mappings[category].items())[:3]
    for effect, value in items:
        print(f"    {effect}: {value}")
